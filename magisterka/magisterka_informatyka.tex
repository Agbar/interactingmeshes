%\textbf{}
\documentclass[12pt, a4paper, final, titlepage]{report}
\usepackage[T1]{fontenc}%polskie litery
%\usepackage{amsart}
\usepackage{amsfonts}
\usepackage[latin2]{inputenc} %pakiet do polskich liter w ISO-8859-2
\usepackage{amsopn}
\usepackage{amssymb}
\usepackage[reqno]{amsmath}
\usepackage{amsthm}
\usepackage{mathrsfs}
\usepackage{indentfirst}
\usepackage[polish]{babel}
\usepackage{polski}

\usepackage{graphicx}
\usepackage{epstopdf}

\DeclareGraphicsExtensions{.pdf,.jpg,.png,.eps,.ps}
\linespread{1.4}

\def\thechapter{\arabic{chapter}}
\def\theequation{\arabic{chapter}\arabic{equation}}

\newtheoremstyle{tw}{12pt}{}{\it}{12pt}{\bf}{.\newline}{0cm}{}
\newtheoremstyle{df}{12pt}{}{}{12pt}{\bf}{.\newline}{0cm}{}
\numberwithin{equation}{chapter} \numberwithin{section}{chapter}
\theoremstyle{tw}
 \theoremstyle{tw}
\newtheorem{tw}{Twierdzenie}[chapter]
\theoremstyle{tw}
\newtheorem{pr}[tw]{Propozycja}
\theoremstyle{tw}
\newtheorem{lm}[tw]{Lemat}
\theoremstyle{df}
\newtheorem{uw}[tw]{Uwaga}
\theoremstyle{df}
\newtheorem{df}[tw]{Definicja}
\theoremstyle{df}
\newtheorem{np}[tw]{Przyk³ad}
%\coï¿½ ode mnie
\theoremstyle{tw}
\newtheorem{wn}[tw]{Wniosek}

\providecommand{\abs}[1]{\lvert#1\rvert}
\providecommand{\norm}[1]{\lVert#1\rVert}
\providecommand{\sk}[1]{\langle#1\rangle}
\providecommand{\ok}[1]{\bigl(#1\bigr)}
\providecommand{\okk}[1]{\biggl(#1\biggr)}
\providecommand{\Okk}[1]{\Biggl(#1\Biggr)}

%\hyphenation{pseudo\-rie\-man\-nowskiej}
\renewcommand{\bibname}{Spis literatury}

\begin{document}

\begin{titlepage}
{\large{\sc{
\begin{center} Uniwersytet Jagielloñski

Wydzia\'l Matematyki i Informatyki\\
%
Instytut Informatyki
\end{center}}}}

\vspace{4cm}
\begin{center}
{\LARGE{Kamil Hawdziejuk}} \vspace{.7cm}
\end{center} {\fontsize{22pt}{30pt}{\bf{
\begin{center}Algorytmy detekcji kolizji obiektów geometrycznych\end{center}}}}

%\vspace{0.5cm}
%\begin{center}
%\large{Praca magisterska}
%\end{center}
\vspace{3cm}

\hspace{5cm} {\textsc{Praca magisterska}}

\hspace{5cm} {\sc{napisana pod kierunkiem:}}

\hspace{5cm} \large{dr. Macieja Slusarka} \vspace{2.6cm}

{\large{\sc{
\begin{center} Kraków, 2010
\end{center}}}}

\end{titlepage}

\def\paragraf{par. }

%\input{sec_wstep}
\tableofcontents

\addcontentsline{toc}{chapter}{\hspace{12pt} Wstêp}

\chapter*{Wstêp}

Detekcja kolizji jest jedn± z fundamentalnych czê¶ci wielu ró¿nych aplikacji. Nachodzenie na siebie obiektów jest czêsto niepo¿±danym stanem. System wykrywania i naprawiania kolizji odpowiadaæ ma w swoim zamierzeniu za zapewnienie poprawnego i stabilnego stanu symulowanego ¶rodowiska, wymuszaj±c odpowiednie zachowanie obiektów w momencie wzajemnej interakcji.
I tak na przyk³ad w grach komputerowych uniemo¿liwia postaciom przechodzenie przez ¶ciany czy te¿ upadanie poni¿ej poziomu pod³ogi. Dostarcza mo¿liwo¶ci takich jak odpowied¼ na pytanie czy jeden u¿ytkownik mo¿e zobaczyæ drugiego, b±d¼ czy jest w zasiêgu strza³u wroga. W robotyce system wykrywania kolizji jest u¿ywany do planowania ruchu i wytyczania ¶cie¿ek poruszaj±cych siê robotów tak, aby nie napotyka³y na przeszkody. W aplikacjach do prototypowania uczestniczy w modelowaniu drogich i wa¿nych czê¶ci przed etapem ich produkcji, co ma ogromny wp³yw na oszczêdno¶æ. Jest tak¿e integraln± czê¶ci± wielu systemów CAD do projektowania przemys³owego, zapewniaj±c wymogi konstrukcyjne produktów firmy. Jest wreszcie u¿ywany w testach zderzeñ, wypadków i katastrof wewn±trz specjalnie do tego celu stworzonych ¶rodowisk symulacyjnych.

W niniejszej pracy przedstawiê systemy detekcji kolizji oraz opiszê najwa¿niejsze algorytmy wykorzystywane do ich wykrywania. Do³±czam wreszcie aplikacjê, która prezentuje wyniki w praktyce. Jest ona integraln± czê¶ci± pracy.
\clearpage

\chapter{Systemy detekcji kolizji}

Istnieje wiele istotnych czynników wp³ywaj±cych na decyzje podejmowane podczas projektowania systemu wykrywania kolizji. Czynniki te mo¿na podzieliæ na nastêpuj±ce kategorie:	

\section{Obiekty i ich reprezentacja}

Wybrana reprezentacja geometryczna dla sceny oraz pojawiaj±cych siê w niej obiektów wp³ywa w oczywisty sposób na algorytmy wykrywaj±ce w niej kolizje. W szczególno¶ci dla reprezentacji z mniejszymi wymogami zaprojektowany  mo¿e byæ bardziej ogólny system.

\begin{df} 
Obiektem geometrycznym nazywamy obiekt przestrzenny reprezentuj±cy figurê geometryczn±, a wiêc dowolny podzbiór punktów przestrzeni euklidesowej.
\end{df}

W niniejszej pracy skupimy siê na obiektach z przestrzeni $R^3$.

Obiekty takie w grafice komputerowej  bardzo czêsto reprezentowane s± w postaci przybli¿onej. Istniej± specjalne algorytmy triangulacji, których zadanie polega na rozbiciu bardziej z³o¿onych obiektów na siatki trójk±tów, które je pokrywaj±. W procesie tym powstaje wielok±t (wielo¶cian), który jest mo¿liwie bliskim przybli¿eniem danego obiektu. Warto w tym miejscu wspomnieæ, ¿e triangulacja coraz bardziej wspierana jest ze strony sprzêtowej i ze wzglêdów wydajno¶ciowych zajmuj± siê tym obecnie pozdespo³y graficzne jeszcze w procesie renderowania. Dlatego te¿ w systemach kolizji najczê¶ciej wybieran± reprezentacj± jest siatka wielok±tów (przewa¿nie trójk±tów) reprezentuj±cych obiekt z przestrzenii. 

W zwi±zku z tym, naszym naturalnym za³o¿eniem w dalszej czê¶ci pracy jest to, i¿  wszystkie analizowane obiekty s± wielo¶cianami, a ka¿dy z nich utworzony jest z:

- ¶cian - wielok±tów, które razem tworz± powierzchniê wielo¶cianu;

- krawêdzi, bêd±cych bokami ¶cian;

- wierzcho³ków, bêd±cych koñcami krawêdzi wielo¶cianu.


\section{Ró¿ne rodzaje zapytañ o kolizje}
Im dok³adniejsze sprawdzenia i wyniki s± potrzebne, tym wiêksza staje siê z³o¿ono¶æ ca³ego systemu zarówno pod k±tem obliczeniowym jak i pamiêciowym. Ponadto nie wszystkie reprezentacje obiektów wspieraj± wszystkie zapytania. Warto zwróciæ na to uwagê.

\section{Parametry ¶rodowiska}
Aplikacja symuluj±ca (np. CAD lub gra) sama w sobie zawiera liczne parametry, które wp³ywaj± po¶rednio b±d¼ bezpo¶rednio na system wykrywania kolizji. Wp³ywaj± na to miêdzy innymi: liczba obiektów, ich rozmiary, pozycje, mo¿liwy sposób poruszania, zezwalanie na przenikanie, tryb ich wykrywania oraz rozwi±zywania itd.

\section{Kwestie wydajno¶ci i mo¿liwo¶ci implementacyjnych}
Systemy detekcji kolizji maj± czêsto du¿y narzut obliczeniowy. Szczególnie w aplikacjach czasu rzeczywistego zak³ada siê, ¿e wykrywanie i rozwi±zywanie kolizji przebiega w sposób p³ynny, on-line.

Nie wszystkie aplikacje wymagaj± tego samego poziomu symulacji ¶rodowiska ponadto wiêkszo¶æ projektów jest ograniczona czasowo. 

\clearpage

\chapter{Algorytmy wykrywania kolizji}

W tym rozdziale przedstawimy szczegó³owo algorytmy odpowiadaj±ce na ró¿ne rodzaje zapytañ o kolizje. Poniewa¿ wykorzystywane s± one g³ównie w aplikacjach czasu rzeczywistego, to ogromne znaczenia ma ich wydajno¶æ. Z drugiej strony czêsto wystarczaj±ca jest przybli¿ona odpowied¼ na to pytanie. W zwi±zku z tym do tematu wykrywania kolizji podchodzi siê etapowo.

Ka¿dy z poszczególnych testów, opisanych w tym rozdziale, odpowiada na pytanie czy istnieje kolizja przy pewnej reprezentacji danych obiektów. Je¶li obiekty s± bardzo z³o¿one, to czêsto wystarczaj±cym testem jest odpowied¼ na pytanie czy np. sfery (prostopad³o¶ciany) opisuj±ce bry³y ze sob± koliduj±. S± to tak zwane szybkie testy, opisane podrozdziale 2.1. Brak kolizji dla tych przybli¿onych reprezentacji oznacza oczywi¶cie brak kolizji dla owych obiektów. Istnienie jej nie oznacza oczywi¶cie, ¿e oba obiekty faktycznie s± ze sob± w kolizji i  mo¿emy wtedy przej¶æ do bardziej szczegó³owych testów. Testy, które mo¿emy przeprowadziæ w kolejnym etapie mog± odrzuciæ nam kolizje, przy za³o¿eniu, ¿e obiekty s± wypuk³e - opisane s± one w podrozdziale 2.2. Kolejne, szczególowe opisane s± w rozdziale 2.3.

\section{Szybki test na prostopad³o¶cianach}

\begin{df}[Zorientowany prostopad³o¶cian otaczaj±cy (OOB)]
Przez OOB (Object oriented box) oznaczaæ bêdziemy prostopad³o¶cian, który jest zorientowany zgodnie z pewn± macierz± orientacji w przestrzeni. 
\end{df}

Test kolizji dwóch obiektów OOB bazuje na nastêpuj±cym fundamentalnym twierdzeniu z analizy bry³ wypuk³ych: 

\begin{tw}[O odzielaj±cej hiperp³aszczy¼nie]
Niech $A$ i $B$ bêd± dwoma niepustymi, roz³±cznymi i wypuk³ymi podzbiorami przestrzeni $R^n$. Istnieje wtedy hiperp³aszczyzna $P$ oddzielaj±ca zbiory A i B, tzn. istnieje wektor $a \in R^n$ , $a \neq 0$, takie ¿e:
$$ \sup {a^Tx} <\sup a^Tz$$
\end{tw}

Test ten  sprawdza, czy dwa zorientowane prostopad³o¶ciany mog± byæ odzielone (odseparowane) w przestrzeni pewn± p³aszczyzn±. Intuicyjnie dwa wypuk³e obiekty nie sa ze sob± w kolizji, je¶li istnieje przerwa pomiêdzy nimi. 

\begin{df}[O¶ odzielaj±ca]
Dla zadanej p³aszczyzny $P$ oddzielaj±cej obiekty $A$ i $B$, definiujemy o¶ odzielaj±c± jako liniê $L$ prostopad³± do $P$. 
\end{df}

O¶ nazywana jest tak, poniewa¿ ortogonalne rzuty takich obiektów $A$ i $B$ na $L$ w rezultacie daj± dwa nieprzecinaj±ce siê przedzia³y. Zauwa¿my od razu, ¿e o¶ odzielaj±ca istnieje wtedy i tylko wtedy, gdy istnieje p³aszczyzna odzielaj±ca. Okazuje siê, ¿e w praktyce o wiele ³atwiej jest wykonywaæ testi na istnienie osi odzielaj±cej, ni¿ p³aszczyzny odzielaj±cej.

Przy ustalonym kierunku $L$, dla ka¿dego z obiektów wyznaczamy punkt najdalej wysuniêty od jego ¶rodka (dla obiektów symetrycznych, takich jak OOB, kierunek wysuniêcia nie ma tutaj znaczenia). Obliczamy nastêpnie promienie $r_A$ i $r_B$, bêd±cymi rzutami tych d³ugo¶ci na kierunek $L$. Obiekty s± odseparowane, je¶li odleg³o¶æ pomiêdzy ¶rodkami tych obiektów jest wiêksza ni¿ odleg³o¶æ pomiêdzy sum± d³ugo¶ci tych promieni, czyli gdy $|T\cdot L| > r_A + r_B$.

\begin{figure}[htbp]
 \centering
    %\includegraphics[width=0.65\textwidth,viewport=50 260 400 1000]{pop10/wykres10.eps}
  \includegraphics[width=1.0\textwidth]{OOB_test.eps}
\caption[Rozmiar 20]{Przeciêcie }
  \label{zrodlo}
\end{figure}

Osie oddzielaj±ce s± stosunkowo ³atwe do wyznaczenia. Na dodatek dla wypuk³ych wielo¶cianów mo¿na znacz±co zredukowaæ ilo¶æ koniecznych testów do przeprowadzenia. Pomijaj±c kolejno¶æ, dwa wielo¶ciany mog± wchodziæ ze sob± w kontakt na 6 ró¿nych sposobów. Mog± to byæ iterakcje ¶ciana-¶ciana, ¶ciana-krawêd¼, ¶ciana-wierzcho³ek, krawêd¼-krawêd¼, krawêd¼-wierzcho³ek lub wierzcho³ek-wierzcho³ek.

Dla przypadków iterakcji ¶ciana-¶ciana i ¶ciana-krawêd¼ wystarczy sprawdziæ normalne ¶cian dla obu obiektów jako potencjalnych osi rozdzielaj±cych. Dla przypadku krawêd¼-krawêd¼ potencjalne osie rozdzielaj±ce to odpowiednio iloczyny wektorowe obu krawêdzi, gdy¿ punkty na krawêdziach najbli¿ej wzglêdem siebie liczone s± po kierunku prostopad³ym do obu z nich. Reasumuj±c test odseparowania dwóch wielo¶cianów mo¿e byæ sprowadzony do przetestowania nastêpuj±cych przypadków:
- osie równoleg³e do normalnych ¶cian obiektu A
- osie równoleg³e do normalnych ¶cian obiektu B
- osie równoleg³e do wektorów bêd±cych iloczynami wektorowymi wszystkich krawêdzi obiektu A z krawêdziami obiektu B

Jak tylko o¶ odzielaj±ca zostanie znaleziona, test zwraca odpowied¼ przecz±c± (brak kolizji). W przypadku, gdy ¿adna z osi nie jest osi± rozdzielaj±c±, kolizja istnieje. Dla dwóch wielo¶cianów o odpowiedniej ilo¶ci ¶cian $F$ oraz ilo¶ci krawêdzi $E$ istnieje potencjalnie $2F + E$ osi rozdzielaj±cych. W zwi±zku z tym, ¿e ¶ciany w obiektach OOB s± równoleg³e do siebie wystarczy tutaj sprawdziæ 15 kierunków, po których nale¿y przetestowaæ przeciêcia dwóch obiektów A i B w scenie 3D. Kierunki te to odpowiednio 3 osie wspó³rzêdnych obiektu A, 3 osie wspó³rzêdnych obiektu B oraz 9 prostopad³ych do ka¿dej kombinacji dwóch pozosta³ych. 

Liczba operacji w te¶cie mo¿e byæ zredukowana przez przeniesienie obiektu B do uk³adu obiektu A.
Niech $t$ bêdzie wektorem przesuniêcia z A do B oraz niech $R = [r_{ij}]$ oznacza macierz przej¶cia z B do A. Wszystkie testy do przeprowadzenia przedstawia poni¿sza tabela:
\begin{figure}[htbp]
 \centering
    %\includegraphics[width=0.65\textwidth,viewport=50 260 400 1000]{pop10/wykres10.eps}
  \includegraphics[width=1.0\textwidth]{OOB_test_table.eps}
\caption[Rozmiar 20]{Testy kolizji}
  \label{zrodlo}
\end{figure}
\clearpage

\section{Test oparty na wypuk³o¶ciach bry³ - algorytm GJK}

W niniejszym rozdziale omówiê szczegó³owo jedn± z najefektywniejszych metod rozwi±zywania kolizji dla zbiorów wypuk³ych -  \textbf{algorytm Gilbert-Johnson-Keerthi}\footnote{Zosta³ opublikowany po raz pierwszy w 1988 roku w pracy Robotics and Automation".}(w skrócie GJK), któr± te¿ zaimplementowa³em w swojej aplikacji. Wyznacza on najmniejsz± odleg³o¶æ pomiêdzy dwoma wypuk³ymi zbiorami i w przeciwieñstwie do wielu innych algorytmów, nie wymaga, aby geometria obiektu by³a przedstawiana w specjalnej formie.
\clearpage
Jak ³atwo zauwa¿yæ
$$dist(A,B) =  min \{ ||a - b|| : a \in A, b \in B \}.$$

Wprowad¼my nastêpuj±c± definicjê:
\begin{df}[Ró¿nica Minkowskiego]
Ró¿nic± Minkowskiego dwóch zbiorów $A$ i $B$ nazywamy zbiór:
$$A \ominus B = \{a-b: a \in A, b \in B \}.$$
\end{df}

Istot±  algorytmu jest to, i¿ nie operuje on na dwóch obiektach explicite, ale na ich ró¿nicy Minkowskiego. Transformacja taka redukuje bowiem problem znalezienia odleg³o¶ci pomiêdzy dwoma wypuk³ymi zbiorami do znalezienia najmniejszej normy w zbiorze $A \ominus B$:
$$dist(A,B) = min \{ ||c|| : c \in A \ominus B\}.$$

Oznaczmy przez $v(A \ominus B)$ punkt taki, ¿e $||v(A \ominus B)|| = dist(A,B)$.

\begin{figure}[htbp]
 \centering
    %\includegraphics[width=0.65\textwidth,viewport=50 260 400 1000]{pop10/wykres10.eps}
  \includegraphics[width=1.0\textwidth]{MinkowskiDifference.eps}
\caption[Rozmiar 20]{Odleg³o¶æ pomiêdzy A i B jest równa odleg³o¶ci pomiêdzy $A \ominus B$, a pocz±tkiem uk³adu wspó³rzêdnych}
  \label{zrodlo}
\end{figure}
Kluczow± cech± algorytmu jest to, ¿e ró¿nica Minkowskiego nie jest obliczana explicite. Mianowicie, bazuje on na metodzie sympleksu i wyznacza w ka¿dym kolejnym kroku iteracji sympleksy $W_k \subset A \ominus B$ tak, aby znajdowa³y siê one coraz bli¿ej pocz±tku uk³adu wspó³rzêdnych. Konstrukcja kolejnego sympleksu opiera siê na nastêpuj±cym pojêciach:

\begin{df}[Otoczka wypuk³a]
Otoczk± wypuk³± zbioru $A$, bêd±cego podzbiorem przestrzeni liniowej jest najmniejszy (w sensie inkluzji) zbiór wypuk³y zawieraj±cy A, oznaczany jako $convA$:
$$convA = \cap \{ M : A \subset M \wedge M - wypuk³y \}.$$
\end{df}

\begin{df}[Funkcja support-mapping]
Dla zbioru wypuk³ego $A \subset R^d$ jest to funkcja $s_A : R^d \rightarrow A$, która rzutuje kierunek $v \in R^d$ w kierunku $A$ tak, ¿e:
$$s_A(v) = max \{ v \cdot x : x \in A\}.$$
Warto¶æ funkcji dla danego wektora, nazywamy support-pointem.
\end{df}

Poniewa¿ funkcja support-mapping jest maksimum pewnej funkcji liniowej, to dla ró¿nicy Minkowskiego dostajemy
$$s_{A \ominus B}(v) = s_A(v) - s_B(-v).$$
i zwi±zku z tym mo¿emy j± obliczaæ obliczaj±c najpierw warto¶æ dla ka¿dego z obiektów $A$ i $B$ osobno.

W algorytmie GJK w ka¿dym kroku iteracji $k$ tworzymy support-point $w_k = s_{A \ominus B}(-v_k)$. Nastêpnie definiujemy $v_{k+1} := v(conv(W_k \cup {w_k}))$ jako punkt po³o¿ony najbli¿ej pocz±tku uk³adu wspó³rzêdnych. Przez $W_{k+1}$ definiujemy najmniejszy zbiór $X \subset W_k \cup{w_k}$ tak, ¿e $v_{k+1}$ nale¿y do $convX$. Wykorzystuje siê tutaj wyniki twierdzenia Caratheodory'ego. Okazuje siê bowiem, ¿e po dodaniu nowych wierzcho³ków do sympleksu, wcze¶niejsze wierzcho³ki nie s± ju¿ wiêcej potrzebne, a za ka¿dym razem $card(W_k) \leq d+1$. 

\begin{tw}[Caratheodory'ego]
Niech $P$ bêdzie podzbiorem przestrzeni $R^d$, a punkt $x \in convP$. Istnieje wtedy podzbiór $P' \subset P$, z³o¿ony z maksymalnie $d+1$ punktów taki, ¿e $x \in convP'$. 
\end{tw}

\begin{proof}
Niech $x \in convP$. Zatem $x$ jest pewn± kombinacj± wypuk³± skoñczonej liczby punktów ze zbioru P:
$$x = \sum\limits_{j=1}^k{\lambda_j x_j},$$
gdzie $x_j \in P$, $\lambda_j > 0$, $\sum\limits_{j=1}^k{\lambda_j}=1$ dla ka¿dego $1 \leq j \leq k$.

Niech $k > d+1$ (w przeciwnym razie teza jest spe³niona). Wtedy punkty $x_2 - x_1$, ..., $x_k - x_1$ s± liniowo zale¿ne. Istniej± wiêc skalary $\mu_2,..., \mu_k$, nie wszystkie zerowe, takie, ¿e:
$$ \sum\limits_{j=2}^k {\mu_j(x_j-x_1)} = 0.$$
\end{proof}


Opieraj±c siê na powy¿szym twierdzeniu, w algorytmie GJK ogranicza siê przeszukiwania, przechowuj±c w ka¿dej iteracji $k$ zbiór $W_k$, z³o¿ony maksymalnie z $d+1$ punktów z $A \ominus B$  i po³o¿ony coraz bli¿ej pocz±tku uk³adu wspó³rzêdnych. Je¶li pocz±tek uk³adu wspó³rzêdnych zawiera siê w aktualnym sympleksie, to oznacza, ¿e obiekty $A$ i $B$ siê przecinaj± i algorytm siê zatrzymuje. W przeciwnym razie zbiór $W_k$ zostaje zaktualizowany tak, aby tworzy³ nowy sympleks, który zawiera punkt bli¿szy pocz±tku uk³adu wspó³rzêdnych ni¿ aktualny sympleks. 

Poka¿emy obecnie, ¿e w ka¿dej iteracji $v_{k+1}$ musi znajdowaæ siê bli¿ej pocz±tku uk³adu wspó³rzêdnych, ni¿ poprzedni punkt $v_k$, poza przypadkami, gdy $v_k$ by³ najbli¿szym punktem.

\begin{tw}[Zbie¿no¶æ metody sympleks]
Niech $k \in N$ i niech $W_k$ bêdzie sympleksem. 

Definiujemy:
\begin{center}
$w_k := s_{A \ominus B}(-v_k)$, 
$v_{k+1} := v(conv(W_k \cup w_k))$ oraz $W_{k+1} := conv(W_k \cup w_k) : v_{k+1} \in conv(W_{k+1}).$
\end{center}

 Wtedy $||v_{k+1}|| \leq ||v_k||$, przy czym równo¶æ zachodzi jedynie wtedy, gdy $v_k = v(A \ominus B)$.
\end{tw}

\begin{proof}

Zauwa¿my, ¿e
$$||v_{k+1}|| = min \{||x||: x \in conv(W_k \cup \{w_k\}) \} \leq ||v_k||,$$ 
gdy¿ $v_k \in conv(W_k)$ oraz $conv(W_k) \subset conv(W_k \cup \{w_k\}).$

Za³ó¿my, ¿e $||v_{k+1}||=||v_k||$. 

Wtedy 
$$\forall x \in  conv(W_k \cup \{w_k\})  :  ||v_k|| \leq ||x||.$$
Poniewa¿ $v_k \in conv(W_k)$, wiêc segment $v_kw_k$ zawiera siê w zbiorze $conv(W_k \cup \{w_k\})$. St±d, dla ka¿dego punktu $u$ na segmencie $v_kw_k$ mamy $ ||v_k|| \leq ||u||$. Zgodnie z lematem 2.9, dostajemy
$$||v_k||^2 - v_k \cdot w_k \leq 0.$$
Z Lematu 2.10 wiemy, ¿e 
$$||v_k||^2 - v_k \cdot w_k \geq 0,$$
zatem
$$||v_k||^2 - v_k \cdot w_k = 0,$$
co mo¿e byæ prawd± jedynie w przypadku $v_k = v(A \ominus B).$
\end{proof}

\begin{lm}
Niech $v$ i $w$ bêd± wektorami z tej samej przestrzeni liniowej. Odcinek o pocz±tku i koñcu w tych punktach zawiera wektor $u$ taki, ¿e $||u|| \leq ||v||$ wtedy i tylko wtedy, gdy $||v||^2 - v \cdot w > 0.$
\end{lm}

\begin{proof}
Niech $u$ nale¿y do segmentu $vw$. Wtedy $u = v + \lambda(w - v)$ dla pewnego $0 \leq \lambda \leq 1$.  Niech $||u|| < ||v||$.

Wtedy
$$||u|| < ||v|| => ||u||^2 - ||v||^2 < 0.$$
Poniewa¿
$$||u||^2 - ||v||^2 = 2\lambda v \cdot (w - v) + \lambda^2||w-v||^2,$$
wiêc
$$2\lambda v \cdot (w - v) + \lambda^2||w-v||^2 < 0.$$
Dla $||w-v||^2 > 0$ rozwi±zania powy¿szej nierówno¶ci, to 
$$\lambda_1 = 0,$$
$$\lambda_2 = -2v \cdot (w-v) / ||w - v||^2,$$
przy czym $$\lambda_2 > 0 <=> -2(vw - ||v||^2) > 0 <=> ||v||^2 - vw > 0.$$

Za³ó¿my teraz, ¿e $||v||^2 - vw > 0$. Wtedy $\lambda_2 > 0$ oraz $||u||^2 - ||v||^2 < 0$ dla ka¿dego $\lambda : 0 = \lambda_1 < \lambda < \lambda_2$. Poniewa¿ $[\lambda_1, \lambda_2] \cap [0,1] \neq \emptyset$, to musi istnieæ punkt $u$ na odcinku $uw$ taki, ¿e $||u|| < ||v||.$

\begin{figure}[htbp]
 \centering
    %\includegraphics[width=0.65\textwidth,viewport=50 260 400 1000]{pop10/wykres10.eps}
  \includegraphics[width=1.0\textwidth]{uv.eps}
\caption[Rozmiar 20]{Segment $uv$ zawiera wektor $u$, dla którego $||u|| < ||v||$ tylko wtedy, gdy $||v||^2 - v \cdot w > 0$.}
  \label{zrodlo}
\end{figure}


\end{proof}

\begin{lm}
$||v_k||^2 - v_k \cdot w_k \geq 0$, przy czym równo¶æ zachodzi jedynie, gdy $v_k = v(A \ominus B).$
\end{lm}

\begin{proof}
Mamy
$$\forall x \in A \ominus B: -v_k \cdot w_k = -v_k \cdot s_{A \ominus B}(-v_k) \geq -v_k \cdot x.$$
Dlatego
$$\forall x \in A \ominus B: (-v_k \cdot x - v_k \cdot w_k ) \geq 0.$$
W szczególno¶ci
$$||v_k||^2 - v_k \cdot w_k  \geq 0.$$
Za³ó¿my, ¿e w powy¿szej nierówno¶ci zachodzi równo¶æ. Wtedy, dla ka¿dego $x \in A \ominus B$:


$||v_k||^2 \leq ||x-v_k||^2 + ||v_k||^2 =  ||x||^2 - 2(v_k \cdot x) + 2||v_k||^2 = ||x||^2 - 2(v_k \cdot x - ||v_k||^2) = ||x||^2 - 2(v_k \cdot x - v_k \cdot w_k) \leq ||x||^2.$

Wobec tego $v_k = v(A \ominus B).$

\end{proof}

\textbf{Algorytm GJK}

1. Zainicjuj sympleks $W_0$ wybieraj±c maksymalnie $d+1$ dowolnych punktów ze zbioru $A \ominus B$.

2. Wybierz punkt $v_k \in convW_k$ o najmniejszej normie.

3. Je¶li $v_k=O$ (tzn. $O \in A \ominus B$), zatrzymaj algorytm i zwróæ odpowied¼, ¿e $A$ i $B$ siê przecinaj±.

4. Zredukuj $W_k$ do najmniejszego podzbioru $W' \subset W$ takiego, ¿e $v_k \in convW'$ poprzez usuniêcie ze zbioru $W_k$ punktów, które nie s± konieczne do reprezentacji podsympleksu $W$ zawieraj±cego $P$.

5. Niech $V=s_{A \ominus B}(-P)=s_A(-P) - s_B(P)$ bêdzie punktem wspieraj±cym w kierunku $-P$.

6. Je¶li $V$ jest najdalszym punktem wysuniêtym w kierunku $-P$, zatrzymaj algorytm i zwróæ odpowied¼, ¿e $A$ i $B$ nie przecinaj± siê. Wielko¶æ $dist(O,P)$ jest odleg³o¶ci± pomiêdzy nimi.

7. Zdefiniuj $W:=W \cup \{P\}$ i przejd¼ do kroku 2.

\begin{figure}[htbp]
 \centering
    %\includegraphics[width=0.65\textwidth,viewport=50 260 400 1000]{pop10/wykres10.eps}
  \includegraphics[width=1.0\textwidth]{GJK.eps}
\caption[Rozmiar 20]{Cztery iteracje algorytmu GJK. Punkty zbioru $W_k$ s± zaznaczone na czarno.}
  \label{zrodlo}
\end{figure}

\clearpage


\section{Struktury podzia³u przestrzeni i test na zbiorach wklês³ych - algorytm BSP}

W¶ród wszystkich problemów wystêpuj±cych w ¶rodowiskach 3D, te odnosz±ce siê do kolizji obarczone s± najbardziej krytycznymi ograniczeniami czasowymi. Wiêkszo¶æ ¶rodowisk z³o¿ona jest z du¿ej liczby (nierzadko skomplikowanych) obiektów, a oczekuje siê, ¿e ca³o¶æ dzia³aæ bêdzie w miarê p³ynny sposób. W zwi±zku z tym wprowadza siê pewne usprawnienia przyspieszaj±ce wykrywanie kolizji, które omówione zostan± w tym rozdziale - podzia³y przestrzeni.

S± to struktury, które dziel±  przestrzeñ $d$-wymiarow± na pary podprzestrzeni (obiekty dziel±ce s± wtedy $(d-1)$-wymiarowymi hiperp³aszczyznami). W szczególno¶ci, scenê 3D przecinaæ mo¿emy p³aszczyznami.

Struktury te zasadniczo wykorzystywane s± na dwa sposoby. Z jednej strony (na poziomie makro) mo¿emy dziêki nim zredukowaæ ilo¶æ koniecznych do przeprowadzenia testów kolizji pomiêdzy wszystkimi obiektami. Zauwa¿my, ¿e dla $n$ obiektów istnieje $1/2 n (n-1)$ par obiektów, które mog± ze sob± kolidowaæ. Wprowadziwszy sensowny podzia³ przestrzeni, mo¿emy liczbê tych par zmniejszyæ do minimum i testowaæ jedynie te, które znajduj± siê w tej samej czê¶ci wydzielonej przestrzeni. Z drugiej strony (na poziomie mikro) wykorzystywane s± do zredukowania liczby koniecznych sprawdzeñ w poszczególnych testach kolizji. W przypadku bowiem, gdy mamy zweryfikowaæ czy dwie skomplikowane siatki ze sob± koliduj±, mo¿emy ograniczyæ testy do tych czê¶ci podzielonej przestrzeni, w której faktycznie kolizja mo¿e dla nich wystêpowaæ\footnote{Drzewa BSP wynalezione zosta³y na pocz±tku jako struktury rozwi±zuj±ce problem reprezentowania niewidocznych miejsc w przestrzeni. Maj± ponadto du¿e zastosowanie w ray traycing'u, kontrukcji obiektów CSG czy planowaniu ¶cie¿ek robotów.}. 

\clearpage
\subsection{Kolizje na zbiorach wklês³ych}

Zauwa¿my, ¿e przedstawionymi wy¿ej podzia³ami mogliby¶my zdekomponowaæ zbiór wklês³y na zbiory wypuk³e i zastosowaæ do wykrycia kolizji ka¿dego z nich algorytm GJK, opisany w poprzednim rozdziale. Niestety, takie podej¶cie, z dwóch powodów, nie jest najw³a¶ciwsze z mo¿liwych. Przede wszystkim zagadnienie znalezienia minimalnego podzia³u zbioru wypuk³ego na zbiory wklês³e jest problemem $NP$-trudnym. Poza tym istnieje obiekt wklês³y z³o¿ony z siatki $n$ trójk±tów, który z³o¿ony jest z $\Omega(n^2)$ zbiorów wypuk³ych. To wszystko doprowadza najczê¶ciej do decyzji postêpowania z zagadnieniem w sposób polegaj±cy na dekompozycji obiektu na mniejsze obiekty, które mog± byæ szybciej przetestowane i niekoniecznie s± zbiorami wypuk³ymi\footnote{Ostatnimi czasy powstaje wiele innych ciekawych podej¶æ, jak np. wyniki naukowców z Texas A\&M University, dotycz±ce algorytmów przybli¿onej dekompozycji zbioru wklês³ego na zbiory wypuk³e, publikowywane na stronie: http://parasol.tamu.edu/groups/amatogroup/research/app-cd/}.

\subsection{Konstrukcja struktury}
Jedn± z najbardziej wszechstronnych metod podzia³u jest tworzenie struktury \textbf{Binary Space-Partitioning tree} (w skrócie BSP tree), któr± te¿ zaimplementowa³em w do³±czanej aplikacji. Polega ona na ko¿dorazowym rekurencyjnym podziale danej przestrzeni hiperp³aszczyzn± na dwie mniejsze wypuk³e czê¶ci (zwane komórkami) i nastêpnie weryfikowanie jedynie kolizji punktów (trójk±tów siatek) nale¿±cych do danych czê¶ci. 

\begin{df}[Drzewo BSP]
Dla danej przestrzeni $R^d$ i hiperp³aszczyzny $h:a_1 x_1 + a_2 x_2 + ... + a_d x_d + a_{d+1} = 0$ niech $h^{+}$ bêdzie otwart± dodatni± pó³przestrzeni± ograniczon± przez $h$, a $h^{-}$ bêdzie otwart± ujemn± pó³przestrzeni± ograniczon± przez $h$:
$$h^{+} :=a_1 x_1 + a_2 x_2 + ... + a_d x_d + a_{d+1} > 0,$$
$$h^{-} :=a_1 x_1 + a_2 x_2 + ... + a_d x_d + a_{d+1} < 0.$$

Drzewo binarnego podzia³u przestrzeni, tzw. drzewo BSP, dla zbioru $S$ obiektów w $d$-wymiarowej przestrzeni definiujemy jako binarne drzewo $T$, z wêz³ami oznaczanymi przez $v$, o nastêpuj±cych w³asno¶ciach:

- je¶li $card(S) \leq 1$, to $T$ jest li¶ciem. Fragment obiektu (je¶li taki istnieje) jest pamiêtany dok³adnie w li¶ciu,

- je¶li $card(S) > 1$, to korzeñ drzewa $T$ pamiêta hiperp³aszczyznê $h$ wraz ze zbiorem obiektów, które s± ca³kowicie w niej zawarte. Lewym dzieckiem wêz³a $v$ jest korzeñ drzewa  BSP $T^{-}$ zawieraj±cy zbiór $S^{-} :=\{h_{v}^{-} \cap s : s \in S\}$, a prawym dzieckiem wêz³a $v$ jest korzeñ drzewa BSP $T^{+}$ zawieraj±cy zbiór $S^{+} := \{h_{v}^{+} \cap s : s \in S\}$
\end{df}


Istnieje kilka mo¿liwych metod konstrukcji struktury drzewa BSP,  w zale¿no¶ci od wyboru hiperp³aszczyzny podzia³u. Wybór "najlepszej" takiej p³aszczyzny wp³ywa rzecza jasna na rozmiar drzewa oraz na wydajno¶æ jego przeszukiwania. Jedn± z mo¿liwych konstrukcji jest tzw. "solid-leaf BSP", polegaj±ca na wyborze jej spo¶ród p³aszczyzn zawieraj±cych ¶ciany wielo¶cianu. Metoda takiego wyboru to tzw. "autopodzia³". 
\begin{figure}[hb]
 \centering
    %\includegraphics[width=0.65\textwidth,viewport=50 260 400 1000]{pop10/wykres10.eps}
  \includegraphics[width=0.75\textwidth]{BSP.eps}
\caption[Rozmiar 20]{Podzia³ przestrzeni na cztery wypuk³e podprzestrzenie razem z odpowiadaj±cym podzia³owi drzewu BSP. (a) pocz±tkowy podzia³. (b) Pierwszy podzia³ drugiego poziomu. (c) Drugi podzia³ drugiego poziomu.}
  \label{zrodlo}
\end{figure}

\clearpage

\subsection{Czas przetwarzania}

Jednym z wa¿niejszych zadañ hierarchi budowanego podzia³u jest utrzymywanie jak najmniejszej liczby wêz³ów w drzewie BSP. Dla wielo¶cianów zbudowanych z siatek metoda autopodzia³u tworzy najczê¶ciej BSP z liczb± wêz³ów zbli¿on± do $O(nlogn)$, gdzie $n$ jest liczb± elementów w drzewie. Tak samo wysoko¶æ zbudowanego drzewa to $O(logn)$, wiêc przeszukiwanie go jest szybkie.
\begin{figure}[h]
 \centering
    %\includegraphics[width=0.65\textwidth,viewport=50 260 400 1000]{pop10/wykres10.eps}
  \includegraphics[width=0.8\textwidth]{BSP_alg.eps}
\caption[Rozmiar 20]{Algorytm konstrukcji drzewa BSP.}
  \label{zrodlo}
\end{figure}

\clearpage

\subsection{Typy}

Drzewa BSP mog± byæ podzielone na wiele sposobów: g³ównie ze wzglêdu na sposób wybierania hiperp³aszczyzny dziel±cej, ale te¿ na sposób przechowywania geometrii (w wierzcho³kach, w li¶ciach), czy obiekt podzia³u (ca³a przestrzeñ czy jeden obiektu). W szczególno¶ci wyró¿niono trzy ich typy: $node-storing$ (przechowywanie w wêz³ach), $leaf-storing$ (przechowywanie w li¶ciach) i $solid-leaf$ (wype³nione li¶æmi). 


\textbf{Przechowywane w wêz³ach}
 W takim przypadku wszystkie ¶ciany, które nale¿± do danej p³aszczyzny podzia³u $h$ l±duj± w wê¼le drzewa, a pozosta³e s± przekazywane rekurencyjnie do poddrzew zgodnie z ich przynale¿no¶ci± do odpowiednich podprzestrzeni $h^{-}$ oraz $h^{+}$ (¶ciany, które przecinaj± siê z $h$ zostaj± podzielona na dwie czê¶ci i równie¿ przekazane do odpowiednich podrzew). Oczywi¶cie li¶cie mog± byæ puste lub zawieraæ tylko jedn± ¶cianê.
\begin{figure}[htbp]
 \centering
    %\includegraphics[width=0.65\textwidth,viewport=50 260 400 1000]{pop10/wykres10.eps}
  \includegraphics[width=1.0\textwidth]{BSP_1.eps}
\caption[Rozmiar 20]{Konstrukcja drzewa BSP przechowuj±cego w wêz³ach: (a) oryginalny 12-k±t. (b) Prosta podzia³u przechodzi przez ¶ciany A i G. (c) Nastêpne proste podzia³u przechodz± odpowiednio przez B i H.}
  \label{zrodlo}
\end{figure}

\textbf{Przechowywane w li¶ciach}
W tym przypadku wierzcho³ki drzewa przechowuj± jedynie p³aszczyznê podzia³u, a ca³a geometria jest przechowywana w li¶ciach. Testy kolizji, wykorzystuj±cych te struktury sprawdzaj± przeciêcia we wszystkich li¶ciach, które zawieraj± w sobie dane obiekty.

\textbf{Wype³nione li¶æmi}


\clearpage
\section{Inne rozwi±zania z literatury}
Istnieje wiele podej¶æ do wykrywania i rozwi±zywania kolizji w scenie. W poprzednich podrozdzia³ach $2.1 - 2.3$ opisa³em szczegó³owo jedynie po jednym z ka¿dego etapu testowania (wszystkie zaimplementowane s± w do³±czanej aplikacji). Wybra³em je, gdy¿ w pewnym sensie s± najbardziej wszechstronne spo¶ród pozosta³ych, przez co wybierane s± te¿ prawdopodobnie jako jedne z najczêstszych.

Chcia³bym obecnie przedstawiæ pokrótce jeszcze kilka innych algorytmów dostêpnych w do³±czanej przeze mnie literaturze.

\underline{Grupa testów, zak³adaj±cych wypuk³o¶æ obiektów}:

Jednym z nich jest \textbf{algorytm V-Clip}, wykorzystuj±cy technikê wspinania na szczyty i tzw. hierarchiczn± reprezentacjê Dobkina-Kirkpatricka.

Kolejnym podej¶ciem jest rozwi±zanie kolizji metodami programowania liniowego, przez zastosowaniu algorytmu \textbf{eliminacji Fourier'a-Motzkin'a}, o z³o¿ono¶ci wyk³adniczej czy te¿ \textbf{algorytmu Seidel'a}, o z³o¿ono¶ci $O(d!m)$.

Istnieje wreszcie \textbf{algorytm Chunk-Wang}, który w wydajny sposób znajduje o¶ rozdzielaj±c± dwa nieprzecinaj±ce siê obiekty.

\underline{Grupa szczegó³owych testów na kolizje}:

Wiêkszo¶æ z nich polega na szczególnym podziale zbioru b±d¼ przestrzenii na mniejsze (tzw. "spatial partitioning"). Przyk³adami hierarchii takiego podzia³u s±: \textbf{k-d tree}, \textbf{quadtree} czy \textbf{octree}. 

\chapter{Metody poprawy wydajno¶ci systemów detekcji kolizji}

Istnieje kilka bardzo istotnych kwestii, które nale¿y poruszyæ omawiaj±c tematykê systemów detekcji kolizji.

\clearpage

\chapter{Aplikacja}

Na potrzeby przetestowania powy¿szych algorytmów napisa³em aplikacjê, dziêki której mo¿na symulowaæ kolizje. Aplikacja znajduje siê pod adresem:
http://code.google.com/p/interactingmeshes/


\section{Opis dzia³ania i interfejs u¿ytkownika}

\section{Wykorzystana technologia i szczegó³y implementacyjne}

 \addcontentsline{toc}{chapter}{\hspace{13pt} Spis
literatury}
\renewcommand{\bibname}{Spis literatury}
\bibliographystyle{plain}
\bibliography{spis_literatury}

1. Christer Ericson, Real-Time Collision Detection", 2005  Elsevier Inc.

2. Gino van den Bergen, "Collision Detection In Interactive 3D Environments", 2003 Elsevier Inc.

3. Philip J.Schneider, David H.Eberly, "Geometric Tools for Computer Graphics", 2003 Elsevier Science

4. Charles Petzold, "3D Programming for Windows"

5. Ron Penton, "Beginning C\# Game Programming", 2003

6. www.geometrictools.com - zestaw u¿ytecznych kodów i algorytmów wykorzystywanych w grafice komputerowej, matematyce, fizyce, geometrii, analizie numerycznej

7. www.microsoft.com/windows/directx - zestaw funkcji API wspomagaj±cych m.in. generowanie grafiki 

\end{document}
