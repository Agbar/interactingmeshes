%\textbf{}
\documentclass[12pt, a4paper, final, titlepage]{report}
\usepackage[T1]{fontenc}%polskie litery
%\usepackage{amsart}
\usepackage{amsfonts}
\usepackage[latin2]{inputenc} %pakiet do polskich liter w ISO-8859-2
\usepackage{amsopn}
\usepackage{amssymb}
\usepackage[reqno]{amsmath}
\usepackage{amsthm}
\usepackage{mathrsfs}
\usepackage{indentfirst}
\usepackage[polish]{babel}
\usepackage{polski}

\usepackage{graphicx}
\usepackage{epstopdf}

\DeclareGraphicsExtensions{.pdf,.jpg,.png,.eps,.ps}
\linespread{1.4}

\def\thechapter{\arabic{chapter}}
\def\theequation{\arabic{chapter}\arabic{equation}}

\newtheoremstyle{tw}{12pt}{}{\it}{12pt}{\bf}{.\newline}{0cm}{}
\newtheoremstyle{df}{12pt}{}{}{12pt}{\bf}{.\newline}{0cm}{}
\numberwithin{equation}{chapter} \numberwithin{section}{chapter}
\theoremstyle{tw}
 \theoremstyle{tw}
\newtheorem{tw}{Twierdzenie}[chapter]
\theoremstyle{tw}
\newtheorem{pr}[tw]{Propozycja}
\theoremstyle{tw}
\newtheorem{lm}[tw]{Lemat}
\theoremstyle{df}
\newtheorem{uw}[tw]{Uwaga}
\theoremstyle{df}
\newtheorem{df}[tw]{Definicja}
\theoremstyle{df}
\newtheorem{np}[tw]{Przyk³ad}
%\coï¿½ ode mnie
\theoremstyle{tw}
\newtheorem{wn}[tw]{Wniosek}

\providecommand{\abs}[1]{\lvert#1\rvert}
\providecommand{\norm}[1]{\lVert#1\rVert}
\providecommand{\sk}[1]{\langle#1\rangle}
\providecommand{\ok}[1]{\bigl(#1\bigr)}
\providecommand{\okk}[1]{\biggl(#1\biggr)}
\providecommand{\Okk}[1]{\Biggl(#1\Biggr)}

%\hyphenation{pseudo\-rie\-man\-nowskiej}
\renewcommand{\bibname}{Spis literatury}

\begin{document}

\begin{titlepage}
{\large{\sc{
\begin{center} Uniwersytet Jagielloñski

Wydzia\'l Matematyki i Informatyki\\
%
Instytut Informatyki
\end{center}}}}

\vspace{4cm}
\begin{center}
{\LARGE{Kamil Hawdziejuk}} \vspace{.7cm}
\end{center} {\fontsize{22pt}{30pt}{\bf{
\begin{center}Algorytmy detekcji kolizji obiektów geometrycznych\end{center}}}}

%\vspace{0.5cm}
%\begin{center}
%\large{Praca magisterska}
%\end{center}
\vspace{3cm}

\hspace{5cm} {\textsc{Praca magisterska}}

\hspace{5cm} {\sc{napisana pod kierunkiem:}}

\hspace{5cm} \large{dr. Macieja Slusarka} \vspace{2.6cm}

{\large{\sc{
\begin{center} Kraków, 2010
\end{center}}}}

\end{titlepage}

\def\paragraf{par. }

%\input{sec_wstep}
\tableofcontents

\addcontentsline{toc}{chapter}{\hspace{12pt} Wstêp}

\chapter*{Wstêp}

Detekcja kolizji jest jedn± z fundamentalnych czê¶ci wielu ró¿nych aplikacji. Nachodzenie na siebie obiektów jest czêsto niepo¿±danym stanem. System wykrywania i naprawiania kolizji odpowiadaæ ma w swoim zamierzeniu za zapewnienie poprawnego i stabilnego stanu symulowanego ¶rodowiska, wymuszaj±c odpowiednie zachowanie obiektów w momencie wzajemnej interakcji.
I tak na przyk³ad w grach komputerowych uniemo¿liwia postaciom przechodzenie przez ¶ciany czy te¿ upadanie poni¿ej poziomu pod³ogi. Dostarcza mo¿liwo¶ci takich jak odpowied¼ na pytanie czy jeden u¿ytkownik mo¿e zobaczyæ drugiego, b±d¼ czy jest w zasiêgu strza³u wroga. W robotyce system wykrywania kolizji jest u¿ywany do planowania ruchu i wytyczania ¶cie¿ek poruszaj±cych siê robotów tak, aby nie napotyka³y na przeszkody. W aplikacjach do prototypowania uczestniczy w modelowaniu drogich i wa¿nych czê¶ci przed etapem ich produkcji, co ma ogromny wp³yw na oszczêdno¶æ. Jest tak¿e integraln± czê¶ci± wielu systemów CAD do projektowania przemys³owego, zapewniaj±c wymogi konstrukcyjne produktów firmy. Jest wreszcie u¿ywany w testach zderzeñ, wypadków i katastrof wewn±trz specjalnie do tego celu stworzonych ¶rodowisk symulacyjnych . 
\clearpage

\chapter{Systemy detekcji kolizji}

Istnieje wiele istotnych czynników wp³ywaj±cych na decyzje podejmowane podczas projektowania systemu wykrywania kolizji. Czynniki te mo¿na podzieliæ na nastêpuj±ce kategorie:	

\section{Obiekty i ich reprezentacja}

Wybrana reprezentacja geometryczna dla sceny oraz pojawiaj±cych siê w niej obiektów wp³ywa w oczywisty sposób na algorytmy wykrywaj±ce w niej kolizje. W szczególno¶ci dla reprezentacji z mniejszymi wymogami zaprojektowany  mo¿e byæ bardziej ogólny system.

\begin{df} 
Obiektem geometrycznym nazywamy obiekt przestrzenny reprezentuj±cy figurê geometryczn±, a wiêc dowolny podzbiór punktów przestrzeni euklidesowej.
\end{df}

W niniejszej pracy skupimy siê na obiektach z przestrzeni $R^3$.

Obiekty takie w grafice komputerowej  bardzo czêsto reprezentowane s± w postaci przybli¿onej. Istniej± specjalne algorytmy triangulacji, których zadanie polega na rozbiciu bardziej z³o¿onych obiektów na siatki trójk±tów, które je pokrywaj±. W procesie tym powstaje wielok±t (wielo¶cian), który jest mo¿liwie bliskim przybli¿eniem danego obiektu. Warto w tym miejscu wspomnieæ, ¿e triangulacja coraz bardziej wspierana jest ze strony sprzêtowej i ze wzglêdów wydajno¶ciowych zajmuj± siê tym obecnie pozdespo³y graficzne jeszcze w procesie renderowania. Dlatego te¿ w systemach kolizji najczê¶ciej wybieran± reprezentacj± jest siatka wielok±tów (przewa¿nie trójk±tów) reprezentuj±cych obiekt z przestrzenii. 

W zwi±zku z tym, naszym naturalnym za³o¿eniem w dalszej czê¶ci pracy jest to, i¿  wszystkie analizowane obiekty s± wielo¶cianami, a ka¿dy z nich utworzony jest z:

- ¶cian - wielok±tów, które razem tworz± powierzchniê wielo¶cianu;

- krawêdzi, bêd±cych bokami ¶cian;

- wierzcho³ków, bêd±cych koñcami krawêdzi wielo¶cianu.


\section{Ró¿ne rodzaje zapytañ o kolizje}
Im dok³adniejsze sprawdzenia i wyniki s± potrzebne, tym wiêksza staje siê z³o¿ono¶æ ca³ego systemu zarówno pod k±tem obliczeniowym jak i pamiêciowym. Ponadto nie wszystkie reprezentacje obiektów wspieraj± wszystkie zapytania. Warto zwróciæ na to uwagê.

\section{Parametry ¶rodowiska}
Aplikacja symuluj±ca (np. CAD lub gra) sama w sobie zawiera liczne parametry, które wp³ywaj± po¶rednio b±d¼ bezpo¶rednio na system wykrywania kolizji. Wp³ywaj± na to miêdzy innymi: liczba obiektów, ich rozmiary, pozycje, mo¿liwy sposób poruszania, zezwalanie na przenikanie, tryb ich wykrywania oraz rozwi±zywania itd.

\section{Kwestie wydajno¶ci i mo¿liwo¶ci implementacyjnych}
Systemy detekcji kolizji maj± czêsto du¿y narzut obliczeniowy. Szczególnie w aplikacjach czasu rzeczywistego zak³ada siê, ¿e wykrywanie i rozwi±zywanie kolizji przebiega w sposób p³ynny, on-line.

Nie wszystkie aplikacje wymagaj± tego samego poziomu symulacji ¶rodowiska ponadto wiêkszo¶æ projektów jest ograniczona czasowo. 

\clearpage

\chapter{Algorytmy wykrywania kolizji}

W tym rozdziale przedstawimy szczegó³owo algorytmy odpowiadaj±ce na ró¿ne rodzaje zapytañ o kolizje. Poniewa¿ wykorzystywane s± one g³ównie w aplikacjach czasu rzeczywistego, to ogromne znaczenia ma ich wydajno¶æ. Z drugiej strony czêsto wystarczaj±ca jest przybli¿ona odpowied¼ na to pytanie. W zwi±zku z tym do tematu wykrywania kolizji podchodzi siê etapowo.

Ka¿dy z poszczególnych testów, opisanych w tym rozdziale, odpowiada na pytanie czy istnieje kolizja przy pewnej reprezentacji danych obiektów. Je¶li obiekty s± bardzo z³o¿one, to czêsto wystarczaj±cym testem jest odpowied¼ na pytanie czy np. sfery (prostopad³o¶ciany) opisuj±ce bry³y ze sob± koliduj±. S± to tak zwane szybkie testy, opisane podrozdziale 2.1. Brak kolizji dla tych przybli¿onych reprezentacji oznacza oczywi¶cie brak kolizji dla owych obiektów. Istnienie jej nie oznacza oczywi¶cie, ¿e oba obiekty faktycznie s± ze sob± w kolizji i  mo¿emy wtedy przej¶æ do bardziej szczegó³owych testów. Testy, które mo¿emy przeprowadziæ w kolejnym etapie mog± odrzuciæ nam kolizje, przy za³o¿eniu, ¿e obiekty s± wypuk³e - opisane s± one w podrozdziale 2.2. Kolejne, szczególowe opisane s± w rozdziale 2.3.

\section{Szybkie testy na sferach i prostopad³o¶cianach}

OOB (Oriented Bounding Box) - Zorientowany prostopad³o¶cian otaczaj±cy.

Test kolizji dwóch obiektów OOB jest testem, który sprawdza czy dwa zorientowane prostopad³o¶ciany mog± byæ odzielone (odseparowane w przestrzeni) pewn± p³aszczyzn±. 

\begin{tw}[Separating plane teory]
Niech $A$ i $B$ bêd± dwoma roz³±cznymi niepustymi i wypuk³ymi podzbiorami przestrzeni $R^n$. Istnieje wtedy hiperp³aszczyzna oddzielaj±ca zbiory A i B.
\end{tw}

Sprawdzamy czy w ustalonym kierunku $L$, suma po³owy d³ugo¶ci przek±tnych zrzutowanych na ten kierunek jest wiêksza ni¿ odleg³o¶æ pomiêdzy rzutem na t± prost± ¶rodków tych prostopad³o¶cianów, czyli gdy $|T\cdot L| > r_A + r_B$.

\begin{figure}[htbp]
 \centering
    %\includegraphics[width=0.65\textwidth,viewport=50 260 400 1000]{pop10/wykres10.eps}
  \includegraphics[width=1.0\textwidth]{OOB_test.eps}
\caption[Rozmiar 20]{Przeciêcie }
  \label{zrodlo}
\end{figure}


Mo¿na udowodniæ, ¿e wystarczy sprawdziæ 15 kierunków, po których nale¿y przetestowaæ przeciêcia dwóch obiektów A i B w scenie 3D. Kierunki te to odpowiednio 3 osie wspó³rzêdnych obiektu A, 3 osie wspó³rzêdnych obiektu B oraz 9 prostopad³ych do ka¿dej kombinacji dwóch pozosta³ych. Je¶li obiekty nie przecinaj± siê na której¶ z nich, to nie mamy do czynienia z kolizj±, w przeciwnym razie tak. 

Liczba operacji w te¶cie mo¿e byæ zredukowana przez przeniesienie obiektu B do uk³adu obiektu A.
Niech $t$ bêdzie wektorem przesuniêcia z A do B oraz niech $R = [r_ij]$ oznacza macierz przej¶cia z B do A. Wsztstkie testy do przeprowadzenia przedstawia poni¿sza tabela:


\begin{figure}[htbp]
 \centering
    %\includegraphics[width=0.65\textwidth,viewport=50 260 400 1000]{pop10/wykres10.eps}
  \includegraphics[width=1.0\textwidth]{OOB_test_table.eps}
\caption[Rozmiar 20]{Testy kolizji}
  \label{zrodlo}
\end{figure}

\section{Testy oparte na wypuk³o¶ciach bry³ - algorytm GJK}

\section{Dok³adne testy - algorytmy BSP i kd-tree}

\clearpage

\chapter{Aplikacja}

\section{Opis dzia³ania i interfejs u¿ytkownika}

\section{U¿yta technologia}

 \addcontentsline{toc}{chapter}{\hspace{13pt} Spis
literatury}
\renewcommand{\bibname}{Spis literatury}
\bibliographystyle{plain}
\bibliography{spis_literatury}

1. Christer Ericson, Real-Time Collision Detection", 2005  Elsevier Inc.

2. Philip J.Schneider, David H.Eberly, "Geometric Tools for Computer Graphics", 2003 Elsevier Science

3. Charles Petzold, "3D Programming for Windows"

4. Ron Penton, "Beginning C\# Game Programming", 2003

5. www.geometrictools.com - zestaw u¿ytecznych kodów i algorytmów wykorzystywanych w grafice komputerowej, matematyce, fizyce, geometrii, analizie numerycznej

6. www.microsoft.com/windows/directx - zestaw funkcji API wspomagaj±cych m.in. generowanie grafiki 

\end{document}
